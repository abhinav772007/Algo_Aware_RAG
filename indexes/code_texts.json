[
  "void bfs(int src, vector<vector<int>>& adj) {\n    vector<bool> visited(adj.size(), false);\n    queue<int> q;\n    visited[src] = true;\n    q.push(src);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n",
  "int binarySearch(vector<int>& arr, int target) {\n    int l = 0, r = arr.size() - 1;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == target) return mid;\n        else if (arr[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n    return -1;\n}\n",
  "void dfs(int u, vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, adj, visited);\n        }\n    }\n}\n",
  "void dijkstra(int src, vector<vector<pair<int,int>>>& adj) {\n    vector<int> dist(adj.size(), INT_MAX);\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\n    dist[src] = 0;\n    pq.push({0, src});\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        if (d > dist[u]) continue;\n        for (auto [v, w] : adj[u]) {\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n",
  "void merge(vector<int>& arr, int l, int m, int r) {\n    vector<int> temp;\n    int i = l, j = m + 1;\n    while (i <= m && j <= r) {\n        if (arr[i] <= arr[j]) temp.push_back(arr[i++]);\n        else temp.push_back(arr[j++]);\n    }\n    while (i <= m) temp.push_back(arr[i++]);\n    while (j <= r) temp.push_back(arr[j++]);\n    for (int k = 0; k < temp.size(); k++)\n        arr[l + k] = temp[k];\n}\n",
  "int maxSumSubarray(vector<int>& arr, int k) {\n    int windowSum = 0, maxSum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        windowSum += arr[i];\n        if (i >= k - 1) {\n            maxSum = max(maxSum, windowSum);\n            windowSum -= arr[i - k + 1];\n        }\n    }\n    return maxSum;\n}\n",
  "bool hasPairSum(vector<int>& arr, int target) {\n    int l = 0, r = arr.size() - 1;\n    while (l < r) {\n        int sum = arr[l] + arr[r];\n        if (sum == target) return true;\n        else if (sum < target) l++;\n        else r--;\n    }\n    return false;\n}\n",
  "int find(int x, vector<int>& parent) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x], parent);\n    return parent[x];\n}\n\nvoid unite(int a, int b, vector<int>& parent, vector<int>& rank) {\n    a = find(a, parent);\n    b = find(b, parent);\n    if (a != b) {\n        if (rank[a] < rank[b]) swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b]) rank[a]++;\n    }\n}\n"
]